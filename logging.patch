From 68daad3264eb54accd61e00d14a2373a1e4fe689 Mon Sep 17 00:00:00 2001
From: Federico Pagnozzi <federico.pagnozzi@ulb.ac.be>
Date: Mon, 11 May 2020 17:54:11 +0200
Subject: [PATCH] Modifications to add the logging needed by AutoMoDeFSMAnalyzer

---
 .gitignore                              |    1 +
 src/AutoMoDeMain.cpp                    |   17 +++++++++---
 src/core/AutoMoDeFiniteStateMachine.cpp |    9 ++++--
 src/core/AutoMoDeFsmBuilder.cpp         |    3 +-
 src/core/AutoMoDeFsmHistory.cpp         |   46 +++++++++++++++++++++++++------
 src/core/AutoMoDeFsmHistory.h           |   11 +++++++-
 src/modules/AutoMoDeBehaviour.cpp       |    6 ++++
 src/modules/AutoMoDeBehaviour.h         |    5 +++
 src/modules/AutoMoDeCondition.cpp       |   16 ++++++++++-
 src/modules/AutoMoDeCondition.h         |   12 +++++++-
 10 files changed, 105 insertions(+), 21 deletions(-)

diff --git a/.gitignore b/.gitignore
index 4581ef2..55a984b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,3 +27,4 @@
 *.exe
 *.out
 *.app
+build
diff --git a/src/AutoMoDeMain.cpp b/src/AutoMoDeMain.cpp
index 74f9c00..f0db15c 100644
--- a/src/AutoMoDeMain.cpp
+++ b/src/AutoMoDeMain.cpp
@@ -26,8 +26,10 @@ using namespace argos;
 const std::string ExplainParameters() {
 	std::string strExplanation = "Missing finite state machine configuration. The possible parameters are: \n\n"
 		" -r | --readable-fsm \t Prints an URL containing a DOT representation of the finite state machine [OPTIONAL]. \n"
-		" -s | --seed \t The seed for the ARGoS simulator [OPTIONAL] \n"
-		" --fsm-config CONF \t The finite state machine description [MANDATORY]\n"
+		" -s | --seed         \t The seed for the ARGoS simulator [OPTIONAL] \n"
+                " -t | --history      \t The controller execution will be logged in a history file [OPTIONAL] \n"
+                " -h | --help         \t if a finite state machine is not specified it will print this message [OPTIONAL] \n"
+		" --fsm-config CONF   \t The finite state machine description [MANDATORY]\n"
 		"\n The description of the finite state machine should be placed at the end of the command line, after the other parameters.";
 	return strExplanation;
 }
@@ -39,7 +41,7 @@ const std::string ExplainParameters() {
 int main(int n_argc, char** ppch_argv) {
 
 	bool bHistory = false;
-
+        bool bHelp = false;
 	bool bReadableFSM = false;
 	std::vector<std::string> vecConfigFsm;
 	bool bFsmControllerFound = false;
@@ -61,10 +63,17 @@ int main(int n_argc, char** ppch_argv) {
 				}
 				// Do not take the FSM configuration into account in the standard command line parsing.
 				n_argc = n_argc - vecConfigFsm.size() - 1;
-			}
+			} else if(strcmp(ppch_argv[nCurrentArgument], "--help") == 0 || strcmp(ppch_argv[nCurrentArgument], "-h") == 0 ){
+                         bHelp = true;
+                        }
 			nCurrentArgument++;
 		}
 		if (!bFsmControllerFound) {
+                        if(bHelp){
+			  //printing help
+                          std::cout << ExplainParameters() << std::endl;
+                          std::exit(0);
+                        }
 			THROW_ARGOSEXCEPTION(ExplainParameters());
 		}
 
diff --git a/src/core/AutoMoDeFiniteStateMachine.cpp b/src/core/AutoMoDeFiniteStateMachine.cpp
index 8f85579..5ac29c4 100644
--- a/src/core/AutoMoDeFiniteStateMachine.cpp
+++ b/src/core/AutoMoDeFiniteStateMachine.cpp
@@ -96,18 +96,21 @@ namespace argos {
 			}
 			else {
 				std::random_shuffle(m_vecCurrentConditions.begin(), m_vecCurrentConditions.end());
+				bool first = true;
 				for (std::vector<AutoMoDeCondition*>::iterator it = m_vecCurrentConditions.begin(); it != m_vecCurrentConditions.end(); it++) {
 					/*
 					 * 3. Update current behaviour
 					 */
-					if ((*it)->Verify()) {
+					bool is_verified = (*it)->Verify(); // To allow the recording of the full log all the transition will be saved in m_mapConditionsCheched
+					if (is_verified && first) {
 						m_mapConditionsChecked.insert(std::pair<AutoMoDeCondition*, bool>((*it), true));
 						m_unCurrentBehaviourIndex = (*it)->GetExtremity();
 						m_pcCurrentBehaviour = m_vecBehaviours.at(m_unCurrentBehaviourIndex);
 						m_bEnteringNewState = true;
-						break;
+						//break;
+						first = false;
 					} else {
-						m_mapConditionsChecked.insert(std::pair<AutoMoDeCondition*, bool>((*it), false));
+						m_mapConditionsChecked.insert(std::pair<AutoMoDeCondition*, bool>((*it), is_verified));
 					}
 				}
 			}
diff --git a/src/core/AutoMoDeFsmBuilder.cpp b/src/core/AutoMoDeFsmBuilder.cpp
index 429af59..e6dc080 100644
--- a/src/core/AutoMoDeFsmBuilder.cpp
+++ b/src/core/AutoMoDeFsmBuilder.cpp
@@ -158,7 +158,6 @@ namespace argos {
 
 	void AutoMoDeFsmBuilder::HandleTransition(std::vector<std::string>& vec_fsm_transition_config, const UInt32& un_initial_state_index, const UInt32& un_condition_index) {
 		AutoMoDeCondition* cNewCondition;
-
 		std::stringstream ss;
 		ss << "--n" << un_initial_state_index << "x" << un_condition_index;
 		std::vector<UInt32> vecPossibleDestinationIndex = GetPossibleDestinationBehaviour(un_initial_state_index);
@@ -199,7 +198,7 @@ namespace argos {
 			cNewCondition->SetOriginAndExtremity(un_initial_state_index, unToBehaviour);
 			cNewCondition->SetIndex(un_condition_index);
 			cNewCondition->SetIdentifier(unConditionIdentifier);
-
+			cNewCondition->SetPbTransition(0.0f);
 
 			// Checking for parameters
 			std::string vecPossibleParameters[] = {"p", "w"};
diff --git a/src/core/AutoMoDeFsmHistory.cpp b/src/core/AutoMoDeFsmHistory.cpp
index d9cf09c..805ae51 100644
--- a/src/core/AutoMoDeFsmHistory.cpp
+++ b/src/core/AutoMoDeFsmHistory.cpp
@@ -10,6 +10,7 @@
 
 #include "AutoMoDeFsmHistory.h"
 
+
 namespace argos {
 
 	/****************************************/
@@ -31,7 +32,9 @@ namespace argos {
 	/****************************************/
 	/****************************************/
 
-	AutoMoDeFsmHistory::~AutoMoDeFsmHistory() {}
+	AutoMoDeFsmHistory::~AutoMoDeFsmHistory() {
+            CloseFile();
+  	}
 
 	/****************************************/
 	/****************************************/
@@ -46,17 +49,42 @@ namespace argos {
 	/****************************************/
 	/****************************************/
 
+	void AutoMoDeFsmHistory::CloseFile() {
+        	
+		for(std::vector<std::string>::iterator it = m_buffer.begin(); it != m_buffer.end(); ++it)
+		{
+			std::cout << *it << std::endl;
+			m_ofHistoryFile << *it << std::endl;
+		}
+//	     m_ofHistoryFile.close();
+	}
+	/****************************************/
+	/****************************************/
+
 	void AutoMoDeFsmHistory::AddTimeStep(UInt32 un_time_step, AutoMoDeBehaviour* pc_current_state, std::map<AutoMoDeCondition*, bool> map_transition_status) {
 		std::stringstream ssInput;
-		ssInput << "--t " << un_time_step << " ";
-		ssInput << "--s" << pc_current_state->GetIndex() << " " << pc_current_state->GetIdentifier() << " ";
-
+		ssInput << "--t " << un_time_step << " "<< "--s" << pc_current_state->GetIndex() << " " << pc_current_state->GetIdentifier() << " ";
+		//ssInput << "--s" << pc_current_state->GetIndex() << " " << pc_current_state->GetIdentifier() << " ";
+               
 		std::map<AutoMoDeCondition*, bool>::iterator it;
+                bool first = true;
+                int t_active = 0;
 		for (it = map_transition_status.begin(); it != map_transition_status.end(); ++it) {
-			ssInput << "--c" << (it->first)->GetIndex() << " "  << (it->first)->GetIdentifier() << " " << (it->second) << " ";
+			if((it->second) && first) { //priting only the first condition that is active (the one choosen by the controller)
+			    ssInput << "--c" << (it->first)->GetIndex() << " "  << (it->first)->GetIdentifier() << " " << (it->second) << " " << (it->first)->GetPbTransition() << " ";
+                            t_active++;
+                            first = false;
+			} else if((it->second)){
+                            t_active++; 
+			    //ssInput << "0 ";
+			}
 		}
-
-		m_ofHistoryFile << ssInput.str() << std::endl;
+		if(t_active > 0) {
+               		ssInput << "--a " << t_active << " "; //printing number of active transitions
+		}
+                        ssInput << "--n " << pc_current_state->GetRobotDAO()->GetNumberNeighbors(); //Printing number of neighbors
+		//m_ofHistoryFile << ssInput.str() << std::endl;
+		m_buffer.push_back(ssInput.str());
 	}
 
 	/****************************************/
@@ -66,8 +94,8 @@ namespace argos {
 		std::stringstream ssInput;
 		ssInput << "--t " << un_time_step << " ";
 		ssInput << "--s" << pc_current_state->GetIndex() << " " << pc_current_state->GetIdentifier() << " ";
-
-		m_ofHistoryFile << ssInput.str() << std::endl;
+		m_buffer.push_back(ssInput.str());
+		//m_ofHistoryFile << ssInput.str() << std::endl;
 	}
 
 	/****************************************/
diff --git a/src/core/AutoMoDeFsmHistory.h b/src/core/AutoMoDeFsmHistory.h
index f9cad9c..5da2247 100644
--- a/src/core/AutoMoDeFsmHistory.h
+++ b/src/core/AutoMoDeFsmHistory.h
@@ -24,6 +24,7 @@
 #include <sstream>
 #include <string>
 #include <map>
+#include <vector>
 
 namespace argos {
 	class AutoMoDeFsmHistory {
@@ -57,6 +58,11 @@ namespace argos {
 			 * Open the file where the history will be saved.
 			 */
 			void OpenFile();
+	                
+			/*
+			 * Prints the content of the buffer to the file
+			 */
+                        void CloseFile();
 
 		private:
 			/*
@@ -68,7 +74,10 @@ namespace argos {
 			 * Content of the history.
 			 */
 			std::ofstream m_ofHistoryFile;
-
+                        /*
+ 			* Buffer to avoid writing conflicts
+ 			*/
+			std::vector< std::string> m_buffer;
 			/*
 			 * Returns the path of the history file.
 			 */
diff --git a/src/modules/AutoMoDeBehaviour.cpp b/src/modules/AutoMoDeBehaviour.cpp
index 95b4572..66af941 100644
--- a/src/modules/AutoMoDeBehaviour.cpp
+++ b/src/modules/AutoMoDeBehaviour.cpp
@@ -146,5 +146,11 @@ namespace argos {
 	void AutoMoDeBehaviour::SetRobotDAO(EpuckDAO* pc_robot_dao) {
 		m_pcRobotDAO = pc_robot_dao;
 	}
+        
+	/****************************************/
+	/****************************************/
 
+        EpuckDAO* AutoMoDeBehaviour::GetRobotDAO() {
+		return m_pcRobotDAO;
+	}
 }
diff --git a/src/modules/AutoMoDeBehaviour.h b/src/modules/AutoMoDeBehaviour.h
index 99e9968..2163ddf 100644
--- a/src/modules/AutoMoDeBehaviour.h
+++ b/src/modules/AutoMoDeBehaviour.h
@@ -169,6 +169,11 @@ namespace argos {
 			 * Setter for the shared pointer to the representation of the robot state.
 			 */
 			void SetRobotDAO(EpuckDAO* pc_robot_dao);
+			
+			/*
+			 * Getter for the shared pointer to the representation of the robot state.
+			 */
+			EpuckDAO* GetRobotDAO();
 	};
 }
 
diff --git a/src/modules/AutoMoDeCondition.cpp b/src/modules/AutoMoDeCondition.cpp
index 1361526..a37b062 100644
--- a/src/modules/AutoMoDeCondition.cpp
+++ b/src/modules/AutoMoDeCondition.cpp
@@ -122,8 +122,22 @@ namespace argos {
 	/****************************************/
 	/****************************************/
 
-  bool AutoMoDeCondition::EvaluateBernoulliProbability(const Real& f_probability) const {
+  bool AutoMoDeCondition::EvaluateBernoulliProbability(const Real& f_probability){
+                m_pbTransition = f_probability; //inserted for loggin purposes
 		return m_pcRobotDAO->GetRandomNumberGenerator()->Bernoulli(f_probability);
 	}
 
+	/****************************************/
+	/****************************************/
+
+  float AutoMoDeCondition::GetPbTransition() {
+		return m_pbTransition;
+	}
+
+	/****************************************/
+	/****************************************/
+
+  void AutoMoDeCondition::SetPbTransition(float pbTransition) {
+		m_pbTransition = pbTransition;
+	}
 }
diff --git a/src/modules/AutoMoDeCondition.h b/src/modules/AutoMoDeCondition.h
index 4a47516..a662dc9 100644
--- a/src/modules/AutoMoDeCondition.h
+++ b/src/modules/AutoMoDeCondition.h
@@ -56,6 +56,10 @@ namespace argos {
 			 */
 			EpuckDAO* m_pcRobotDAO;
 
+                        /*
+                         * Transition probability as calculated in the last control step.
+                         */
+			float m_pbTransition;
 		public:
 
 			virtual ~AutoMoDeCondition(){};
@@ -111,6 +115,12 @@ namespace argos {
 			const UInt32& GetIdentifier() const;
 
 			/*
+ 			 * Getter and setter for the transition probability
+                         */
+                        float GetPbTransition();
+                        void SetPbTransition(float pbTransition);
+
+			/*
 			 * Adds a pair <parameter, value> to the parameters map.
 			 */
 			void AddParameter(const std::string& str_identifier, const Real& f_value);
@@ -138,7 +148,7 @@ namespace argos {
 			/*
 			 * Returns a random value from a Bernoulli distribution.
 			 */
-			bool EvaluateBernoulliProbability(const Real& f_probability) const;
+			bool EvaluateBernoulliProbability(const Real& f_probability);
 	};
 }
 
-- 
1.7.1

